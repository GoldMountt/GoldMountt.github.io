---
layout: single
title: "c++3단원"
toc: true
---
## 변수
>알아야 할 것 3가지
+ 어디에?
+ 어떤 값이?
+ 어떤 종류인가?
> EX) int braincount; <br>    braincount = 5;<br> braincount 라는 곳에 5라는 값을 종류는 int형

 
### 변수 이름 규칙

>   1. 염문자,숫자,밑줄(_) 문자만 사용가능
>    2. 숫자는 첫 문자로 사용 불가능
>   3. 대문자 소문자 구별
>    4. 키워드는 변수 이름으로 사용 불가능
>   5. 두개의 밑줄 혹은 밑줄 문자와 대문자로 시작하는 이름은, 그것을 <br>사용하는 컴파일러와 리소스가 사용하기로 예약되어 있다.
>  6. 줄 문자로 시작하는 이름은, 그것을 사용하는 컴파일러와 리소스가 전역 식별자로 사용하기로 예약되어 있다.
## 정수형
+ 소수부가 없는 수
> EX) 2.98,-182,0

#### 여러가지 정수형
> 정수는 메모리의 크기가 다른 4가지 형태가 있다
+ short : 최소한 16비트 폭을 가진다.
+ int : 최소한 short 만큼은 크다.
+ long : 최소 32비트 ,최소 int만큼은 크다.
+ long long형은 최소한 64비트 폭, 최소 long만큼
#### 정수의 크기를 알아내는 연산자 
+ sizeof
> EX) sizeof (정수형) or sizeof 변수이름
+ climits 헤더파일
> 데이터형의 한계값을 나타내기 위햐 기호 상수를 사용한다.
> EX) INT_MAX == int형으로 나타낼 수 있는 최대값을 의미

### 초기화
> **선언** 과 **대입** 을 하나로 조합한다.<br>EX) int n_int = INT_MAX;
<br> n_int를 int형 변수로 선언하며 그 변수에 int형의 최대값을 대입

### unsigned형
> 음의 정수값을 가질 수 없지만 양의 정수값의 범위가 늘어나는 변형
> <br> EX) short형의 범위 -32768 ~ 32768 
> <br> *unsigned* short의 범위 0 ~ 65535
 ### 정수형 선택
 > 특정 상황을 제외하고는 *int*형 사용을 권고
<br> EX)
+int형의 최대 범위보다 더 큰 정수를 나타내야 할 경우
+작은 크기라면 더 작은 메모리를 사용하며 메모리 절약 가능

> 프로그램도 특정 상황을 제외하고는 상수를 int형으로 저장
+ EX) long을 나타내는 l,L 접미어와 같은거를 붙이거나 혹은 값이 int범위를 넘었을 때
#### char형
> 문자와 숫자를 저장하기 위한 것

>EX) 문자와 숫자,구두점과 같은 기호들 (아스키코드)

> char자료형에 cin함수로 문자를 받으면 이 문자를 숫자로 바꿔서 저장하고 <br>
cout함수는 이 숫자를 다시 문자로 바꿔서 출력한다.

### 멤버 함수: cout.put()
> 멤버 함수는 그 클래스의 특정 객체를 통해서만 사용할 수 있다.

> cout 객체를 통해 put()이라는 멤버 함수를 사용한다.

### bool형
> 참과 거짓 truedhk false를 나타내는 자료형

### const 제한자
> const 데이터형 상수이름 = 값;
+ const 제한자를 사용하여 변수를 선언하고 초기화한 형태로 <br>
*값을 바꾸지 못한다*.

> 써야하는 이유

1. 데이터형을 명시적으로 지정할 수 있다 
2. c++ 활동 범위 규칙에 의해 그 정의를 특정 함수나 파일에서만 사용할 수 있도록 제한할 수 있다
3. 배열이나 구조체와 같은 베이터형에도 const 사용가능

## 부동 소수점수
> 0.56 과같이 소수점이 있는 수 혹은 너무 커서 long형으로 나타낼 수 없는 경우에 사용

### 표기 
+ 일상생활에서 사용하는 소수점 표기법 그대로 사용
>EX) 12.34 ,8.0
+ 지수 표기
>EX) 3.45E6,8.33E-4

### 부동 소수점
> 유효 숫자의 개수와 지수의 최소 허용 범위에 따라 나뉜다
<br> (2745 미터의 유효 숫자 개수는 4개 , 2700미터 유효 숫조 개수는 2개 즉 0은 자리만 차지)
1. float : 최소 32비트
2. double: float형보다 작지 않으면서 최소 48비트
3. long double : 최소한 double형과 같은 크기를 요구

>프로그램은 부동 소수점형 상수를 기본적으로 double형으로 저장
<br> float은 f or F , long double은 l or L 접미어를 붙여 저장

#### 장점
1. 정수와 정수 사이에 있는 값을 나타낼 수 있다.
2. 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.

#### 단점
1. 수치 연산 보조 프로세서가 없으면 연산 속도가 느리다
2. 정밀도를 잃을 수 있다.

## C++ 산술 연술자
> 연산자와 피연산자가 결합되어 수식을 구성
<BR> int wheels = 4 + 2; (피연산자: 4 와 2 ,연산자: +)

### 연산 순서
> 곱셈 나눗셈 먼저 , 윈쪽에서 오른쪽으로 연산

## 나눗셈 
> 나눗셈 연산자는 피연산자 모두 정수면 소수부를 버리고 정수 결과를 만들지만
><br> 피연산자 하나 혹은 둘이 부동 소수점이면 결과는 부동 소수점이 된다

>EX)
+ 정수 나눗셈 :9/5 = 1
+ 부동 소수점수 나눗셈: 9.0/5.0 = 1.800000
+ 혼합 나눗셈: 9.0/5 = 1.800000
>> C++ 은 문맥을 파악하여 어느 연산을 수행할 것인지를 결정한다. 이것을 *연산자 오버로딩*이라 한다
  
### 나머지셈 연산자
> 정수 나눗셈의 나머지를 리턴

> EX) 181 % 14 = 13

## 데이터형 변환
> 컴퓨터는 여러 데이터형을 혼합하여 되어 있을 때 데이터형의 불일치를 해결하기 위해 특정 상황에서 데이터형 변환을 수행
+ 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때
  > 범위가 작은 데이터형의 값을 범위가 큰 데이터형에는 상관 없지만 반대는 상관있다
+ 수식에 데이터형을 혼합하여 사용했을 때
+ 함수에 매개변수를 전달할 때

|데이터형 변환|문제점|
|--|--|
|double --> float 큰 데이터형에서 작은 데이터형| 정밀도 손실. 범위가 넘어가면 결과 예측 불가|
|부동 소수점형 --> 정수|소수부를 잃는다,범위가 넘어가면 결과 예측 불가|
|long --> short 큰 정수형 --> 작은 정수형|원래 값이 변환 데이터형을 벗어날 경우 ,대개 하위 바이트들만 복사|

#### 강제 형변환
+ (강제로 변환할 데이터형) 변환할 데이터 이름 












