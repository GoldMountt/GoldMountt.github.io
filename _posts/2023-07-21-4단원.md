## 배열
> 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조

>선언 3가지 
+ 각 원소에 저장될 값의 데이터형
+ 배열의 이름
+ 배열 원소의 개수
#### 형식
> typeNmae arrayName[arraySize];
> <br>EX)
```short months[12]; // 12개의 short형 값을 넣을 수 있는 배열을 생성```

> 인덱스는 항상 배열의 크기보다 1만큼 작다

> 인덱스는 0부터 시작하여 (배열의 크기 -1) 까지 순서대로 존재한다

```cpp
int main()      //함수 머리
{
    uisng namespace std;
    int yams[3]; // 3개의 원소를 가진 배열 생성
    yams[0] = 1 // 첫 번째 원소에 값을 대입
    yams[1] = 2
    yams[2] = 3
 
}
```
```cpp
int yamcosts[3] = {200,300,50} //배열을 생성하고 초기화
```
#### 초기화 규칙
1. 초기화를 나중에 할 수 없다.
> EX) hand[4] = {5,6,7,9); 

2.배열을 다른 배열에 통째로 대입 불가능
> EX) hand = 다른배열;
3. 배열을 부분적으로 초기화하면 컴파일러가 나머지 원소들을 모두 **0** 으로 설정

## 문자열
> 문자열이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말하며<br>
처리하는 방법으로는 두가지가 있다.
1. char형 배열로 처리하는 방법
```cpp char dog[8] = {'b','e','a','u','x',' ','i','\0'};```
> 모든 문자열의 마지막 문자는 반드시 널 문자 (**\0**) 여야 한다

> cout과 같은 함수들은 이러한 배열을 출력할 때 널을 만나야 중단하기 때문

2.문자열로 묶는 방법
```cpp char dog[8] ="beauxi";```
> 이러한 경우 널 문자를 암시적으로 가지고 있다.

+ ) 큰따옴표를 사용하는 무나졍ㄹ 상수와 작은따음표를 사용하는 문자 상수는 서로 바꾸어 쓸 수 없다.
> 왜냐하면 char shirt = 'S'; 는 83을 대입하지만 <br>
char shirt = "S";은 메모리 주소를 대입하려 시도하게 되기 때문

### 문자열 상수의 결합
> 빈칸, 탭, 캐리지 리턴과 같은 화이트스페이스로 분리된 두개의 문자열 상수는 하나의 문자열 상수로 결합
```cpp
cout << "I'd give myright arm to be" " a great violinist.\n";
cout << "I'd give myright arm to be a great violinist.\n";
cout << "I'd give myright arm to be" 
" a great violinist.\n";
```
위 세가지 경우 출력이 모두 동등하다.

### 배열에 문자열 사용
배열에 문자열을 넣는 가장 일반적인 방법으로는
1. 배열에 문자열 상수로 초기화하는 방법
2. 키보드 입력이나 파일 입력을 배열에 저장하는 방법
+ sizeof : 배열에 전체크기 리턴 <br>
+ strlen(): 배열에 저장된 문자열 크기 리턴(마지막 널은 제외한 크기)

### 문자열 입력
+ 예시코드
```cpp
#include <iostream>    
int main()      
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char sessert[ArSize];

    cout << "이름을 입력하십시오:\n";
    cin >> name;
    cout << "좋아하는 디저트를 입력하십시오:\n";
    cin >> dessert;
    cout << "맛있는" << dessert;
    cout << "디저트를 준비하겠습니다." << name << "님!\n";

}               
```
이러한 경우 결과는
```
이름을 입력하십시오:
kumsan prak
좋아하는 디저트를 입력하십시오:
맛있는 park 디저트를 준비하겠습니다. kumsan 님!
```
위와 같이 디저트에 입력을 받지않고 모든 줄을 출력하게 된다
###### 이유
+ cin이 문자열의 끝을 알아야 하는데 키보드로 널을 입력할 수 없어 <br>
cin은 빈칸 , 탭 ,캐리지 리턴과 같은 화이트스페이스가 있으면 끝으로 간주
> 위에 예제에서는 그러한 cin의 특성 때문에 cin은 kumsan를 온전한 문자열로 읽어name 배열에 저장하고<br>
park는 입력큐에 그대로 남겨두고 다시 cin이 입력큐를 검사할 때 남아있던 park가 문자열로 읽히게 된 것이다.

> 이러한 상황에 사용가능한 함수

+ getline()
> 이 함수는 enter 키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다.

+get()
>  이 함수는 위 함수와 똑같이 작동하지만 개행 문자를 읽고 버리지 않고 입력 큐에 그대로 남겨둔다
<br> 그래서 첫번째 호출 이후 남겨진 개행문자가 두번째 호출때 첫 문자로 만나게 되어 바로 끝을 낸다.
<br> 그렇기에 아래와 같은 형식으로 사용해야 한다

```cpp
cin.get(name,ArSize); 
cin.get(); 
cin.get(name2,ArSize);
```
+ 혹은
```cpp
cin.get(name1,ArSize).get();
```

### string 클래스 
> 문자 배열 대신에 문자열을 저장하는 방식
<br>string 클래스를 사용하려면 ,프로그램에 string 헤더 파일을 포함 시켜야 한다.

```cpp
#include <iostream>    
int main()      
{
    using namespace std;
    char name1[20];
    char name2[20] = "hi";
    string str1;
    string str2 = "hello"

    cin >> name1;
    cin >> str1;
    cout << str1; << << str2 << endl;
    cout << name1 << name2 << endl;
    cout << name2 << "에서 세 번째 글자:"
    << name2[2] << endl;
    cout << str2 << "에서 세 번째 글자:"
    << str2[2] << endl;
    
    return 0;
}               
```
> 위 예제를 통해 알 수 있는 사실
+ c스타일 문자열로 string 객체를 초기화할 수 있다.
+ cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.
+ cout을 사용하여 string 객체를 디스플레이할 수 있다.
+ 배열 표기를 사용하여 srting 객체에 저장되어 있는 개별적인 문자들에 접근할 수 있다

> > 차이점으로는 srting 객체는 배열이 아닌 단순한 변수로 선언하는 것이다. <br>
이것이 가능한 이유는 string은 프로그램이 입력을 읽어 넣을 때 크기를 자동으로 조절하기 때문

+ 대입 결합 추가
```
char charr1[20];
char charr2[20] = "hi";

string str1;
string str2 = "hello";

charr1 = charr2; // 틀리다

str1 = str2; // 가능
```
> 위와 같은 예제로 알 수 있듯이 하나의 배열은 다른 배열에 간단히 대입할 수 없지만 <br>
하나의 string 객체를 다른 string객체에 간단하게 대입이 가능하다.
```cpp
string str3 
str3 = str1 + str2; //결합된 두 string객체를 str3에 대입
str1 += str2; // str1의 끝에 str2를 추가
```
### 구조체
> 서로 관련된 정보를 하나의 단위로 묶어서 저장
+ 하나의 구조체 안에 여러 종류의 데이터를 저장가능

#### 생성
1. 구조체 서술
+ 구조체 안에 여러 가지 데이터형들을 서술하고 이름을 정한다
```cpp
struct inflatable // 구조체 선언
{
    char name[20]; //멤버들
    float voulume;
    double price;
    
};
```

2.구조체 변수 생성 ( 데이터 객체를 생성 )
```cpp
inflatabel hat;
inflatable woopie
inflatable mainframe;
```
> hat가 inflatable 형이라면, 멤버 연산자(.)를 사용하여 그 구조체의 개별적인 접근 가능
<br> EX) hat.volume은 hat변수의 volume 멤버를 나타냄

```cpp
struct inflatable // 구조체 선언
{
    char name[20];
    float voulume;
    double price;

};


int main()
{
    using namespace std;
    inflatable guest = 
    {
        "Glorious Gloria", //name 값
        1.88,              //volume 값
        29.99              // price 값
    };                     // guest는 inflatable형의 구조체 변수이다


    inflatable pal =
    {
        'Audacious Arthur',
        3.12;
        32.99;
    };              // pal은 inflatable형의 두 번째 수이다
    
}
```
> 위와 같이 구조체 선언과 변수를 만들어 주고
```cpp
cout << guest.name;
cout << pal.name
//pal.name은 pal변수의 name 멤버이다
cout << guest.price + pal.price
```
> 이런 식으로 사용 가능
+ guest.name; 은 Glorious Gloria
+ pal.name은 Audacious Arthur
+ 마지막 줄과 같이 연산도 가능하여 결과 값으로 두 수의 합이 나온다

#### 구조체 선언 위치
1. main() 함수의 안에 여는 중괄호 바로 뒤에 선언
+ 이러한 선언을 내부 선언

> 그 선언이 들어 있는 함수에서만 사용 가능
2. main() 함수의 앞에 선언
+ 이러한 선언을 외부 선언이라 한다

> 외부 선언에 경우 외부 선언 이후에 나오는 모든 함수 사용 가능

#### 기타 특성
1. 구조체를 함수에 매개변수로 전달할 수 있다
2. 구조체를 리턴값으로 사용할 수도 있다.
3. 대입 연산자(=)를 사용하여 하나의 구조체를 다른 하나의 데이터형이 같은 <br>구조체에 대입이 가능하다

#### 구조체의 배열
```cpp
int main()
{
    using namespace std;
    inflatable guests[2] =  // 구조체의 배열 초기화
    {
        {"name1",0.5,21.99},  // 배열에 있는 첫 구조체
        {"name2",2000,565.99} // 배열에 있는 다음 구조체
    };

    cout  << guests[0].name //과 같은 형식으로 불러온다
    
}
```



