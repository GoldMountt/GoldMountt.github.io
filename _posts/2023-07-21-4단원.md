## 배열
> 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조

>선언 3가지 
+ 각 원소에 저장될 값의 데이터형
+ 배열의 이름
+ 배열 원소의 개수
#### 형식
> typeNmae arrayName[arraySize];
> <br>EX)
```short months[12]; // 12개의 short형 값을 넣을 수 있는 배열을 생성```

> 인덱스는 항상 배열의 크기보다 1만큼 작다

> 인덱스는 0부터 시작하여 (배열의 크기 -1) 까지 순서대로 존재한다

```cpp
int main()      //함수 머리
{
    uisng namespace std;
    int yams[3]; // 3개의 원소를 가진 배열 생성
    yams[0] = 1 // 첫 번째 원소에 값을 대입
    yams[1] = 2
    yams[2] = 3
 
}
```
```cpp
int yamcosts[3] = {200,300,50} //배열을 생성하고 초기화
```
#### 초기화 규칙
1. 초기화를 나중에 할 수 없다.
> EX) hand[4] = {5,6,7,9); 

2.배열을 다른 배열에 통째로 대입 불가능
> EX) hand = 다른배열;
3. 배열을 부분적으로 초기화하면 컴파일러가 나머지 원소들을 모두 **0** 으로 설정

## 문자열
> 문자열이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말하며<br>
처리하는 방법으로는 두가지가 있다.
1. char형 배열로 처리하는 방법
```cpp char dog[8] = {'b','e','a','u','x',' ','i','\0'};```
> 모든 문자열의 마지막 문자는 반드시 널 문자 (**\0**) 여야 한다

> cout과 같은 함수들은 이러한 배열을 출력할 때 널을 만나야 중단하기 때문

2.문자열로 묶는 방법
```cpp char dog[8] ="beauxi";```
> 이러한 경우 널 문자를 암시적으로 가지고 있다.

+ ) 큰따옴표를 사용하는 무나졍ㄹ 상수와 작은따음표를 사용하는 문자 상수는 서로 바꾸어 쓸 수 없다.
> 왜냐하면 char shirt = 'S'; 는 83을 대입하지만 <br>
char shirt = "S";은 메모리 주소를 대입하려 시도하게 되기 때문

### 문자열 상수의 결합
> 빈칸, 탭, 캐리지 리턴과 같은 화이트스페이스로 분리된 두개의 문자열 상수는 하나의 문자열 상수로 결합
```cpp
cout << "I'd give myright arm to be" " a great violinist.\n";
cout << "I'd give myright arm to be a great violinist.\n";
cout << "I'd give myright arm to be" 
" a great violinist.\n";
```
위 세가지 경우 출력이 모두 동등하다.

### 배열에 문자열 사용
배열에 문자열을 넣는 가장 일반적인 방법으로는
1. 배열에 문자열 상수로 초기화하는 방법
2. 키보드 입력이나 파일 입력을 배열에 저장하는 방법
+ sizeof : 배열에 전체크기 리턴 <br>
+ strlen(): 배열에 저장된 문자열 크기 리턴(마지막 널은 제외한 크기)

### 문자열 입력
+ 예시코드
```cpp
#include <iostream>    
int main()      
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char sessert[ArSize];

    cout << "이름을 입력하십시오:\n";
    cin >> name;
    cout << "좋아하는 디저트를 입력하십시오:\n";
    cin >> dessert;
    cout << "맛있는" << dessert;
    cout << "디저트를 준비하겠습니다." << name << "님!\n";

}               
```
이러한 경우 결과는
```
이름을 입력하십시오:
kumsan prak
좋아하는 디저트를 입력하십시오:
맛있는 park 디저트를 준비하겠습니다. kumsan 님!
```
위와 같이 디저트에 입력을 받지않고 모든 줄을 출력하게 된다
###### 이유
+ cin이 문자열의 끝을 알아야 하는데 키보드로 널을 입력할 수 없어 <br>
cin은 빈칸 , 탭 ,캐리지 리턴과 같은 화이트스페이스가 있으면 끝으로 간주
> 위에 예제에서는 그러한 cin의 특성 때문에 cin은 kumsan를 온전한 문자열로 읽어name 배열에 저장하고<br>
park는 입력큐에 그대로 남겨두고 다시 cin이 입력큐를 검사할 때 남아있던 park가 문자열로 읽히게 된 것이다.

> 이러한 상황에 사용가능한 함수

+ getline()
> 이 함수는 enter 키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다.

+get()
>  이 함수는 위 함수와 똑같이 작동하지만 개행 문자를 읽고 버리지 않고 입력 큐에 그대로 남겨둔다
<br> 그래서 첫번째 호출 이후 남겨진 개행문자가 두번째 호출때 첫 문자로 만나게 되어 바로 끝을 낸다.
